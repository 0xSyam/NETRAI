import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:livekit_client/livekit_client.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter/services.dart'; // Required for MethodChannel mocking

// Assuming these are in the correct relative path from the test file
import 'package:netrai/services/connection_service.dart';
import 'package:netrai/services/token_service.dart';

// Generate mocks for these classes
@GenerateNiceMocks([
  MockSpec<Room>(),
  MockSpec<Events>(),
  MockSpec<LocalParticipant>(),
  MockSpec<TokenService>(),
  MockSpec<Connectivity>(),
])
import 'connection_service_test.mocks.dart'; // This file will be generated by build_runner

void main() {
  // TestWidgetsFlutterBinding.ensureInitialized(); // Might be needed for platform channel mocks

  late MockRoom mockRoom;
  late MockEvents mockEvents;
  late MockLocalParticipant mockLocalParticipant;
  late MockTokenService mockTokenService;
  late MockConnectivity mockConnectivity;
  late ConnectionService connectionService;

  // --- Permission Handler Mocking Setup ---
  // StandardMethodCodec is used by permission_handler
  const MethodChannel channel = MethodChannel('flutter.base/permission_handler');
  final List<MethodCall> Plog = <MethodCall>[]; // To log method calls to the channel

  setUpAll(() {
    // This is needed to mock platform channels like permission_handler
    TestWidgetsFlutterBinding.ensureInitialized(); 
  });
  
  setUp(() {
    mockRoom = MockRoom();
    mockEvents = MockEvents();
    mockLocalParticipant = MockLocalParticipant();
    mockTokenService = MockTokenService();
    mockConnectivity = MockConnectivity();

    // Default stub for room.events
    when(mockRoom.events).thenAnswer((_) => Stream<RoomEvent>.empty());
    // Default stub for room.localParticipant (can be overridden in specific tests)
    when(mockRoom.localParticipant).thenReturn(mockLocalParticipant);
    when(mockRoom.connectionState).thenReturn(ConnectionState.disconnected);


    // Initialize ConnectionService with mocks
    // Note: LIVEKIT_URL environment variable needs to be handled.
    // For tests, we can pass a dummy URL or ensure it's set if ConnectionService relies on it.
    // For now, let's assume ConnectionService can take a direct URL or a default.
    // We will pass a dummy initialServerUrl to avoid issues with const String.fromEnvironment
    connectionService = ConnectionService(mockRoom, mockTokenService, initialServerUrl: 'ws://dummy-url:7880');

    // --- Permission Handler Mocking ---
    // Clear previous log
    Plog.clear();

    // Mock platform channel calls for permission_handler
    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(channel, (MethodCall methodCall) async {
      Plog.add(methodCall); // Log the call
      if (methodCall.method == 'checkPermissionStatus') {
        // Default to denied, tests can override this
        return PermissionStatus.denied.index;
      }
      if (methodCall.method == 'requestPermissions') {
        // Default to granted when requested, tests can override
        return { (methodCall.arguments as List<int>).first : PermissionStatus.granted.index };
      }
      return null;
    });
  });

  tearDown(() {
    connectionService.dispose();
    // Reset mock method call handlers
    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(channel, null);
  });

  group('ConnectionService Initialization', () {
    test('should initialize with initial state and message', () async {
      expect(
        connectionService.statusStream,
        emits(isA<ConnectionStatusUpdate>().having(
          (s) => s.state, 'state', ConnectionStateUpdate.initial
        ).having(
          (s) => s.message, 'message', "Service initialized" // Or whatever the initial message is
        ))
      );
    });

    // Test for missing LIVEKIT_URL (difficult to test const String.fromEnvironment directly)
    // This would require running the test with the environment variable explicitly unset,
    // or refactoring ConnectionService to always take the URL as a constructor argument.
    // For now, we assume the constructor argument `initialServerUrl` handles this.
    test('constructor handles null or empty initialServerUrl gracefully (emits configuration error if used for connection)', () async {
        // This test focuses on the fact that ConnectionService can be constructed.
        // The actual error emission would happen during a connect attempt if URL is bad.
        final serviceWithEmptyUrl = ConnectionService(mockRoom, mockTokenService, initialServerUrl: '');
        final serviceWithNullUrl = ConnectionService(mockRoom, mockTokenService, initialServerUrl: null);
        
        expect(serviceWithEmptyUrl, isNotNull);
        expect(serviceWithNullUrl, isNotNull);

        // A more direct test for error emission on connect:
        when(mockTokenService.fetchToken(any, any)).thenThrow(Exception("Simulated error due to bad URL"));
        
        serviceWithEmptyUrl.connect(roomName: "test", participantName: "test");

        await expectLater(
            serviceWithEmptyUrl.statusStream,
            emitsThrough(isA<ConnectionStatusUpdate>().having(
                (s) => s.errorType, 'errorType', ErrorType.configuration
            ))
        );
        serviceWithEmptyUrl.dispose();
        serviceWithNullUrl.dispose();
    });

  });

  group('Connection Flow', () {
    setUp(() async {
      // Default permission status (granted)
      TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(channel, (MethodCall methodCall) async {
        if (methodCall.method == 'checkPermissionStatus') {
          return PermissionStatus.granted.index;
        }
        if (methodCall.method == 'requestPermissions') {
           return { (methodCall.arguments as List<int>).first : PermissionStatus.granted.index };
        }
        return null;
      });

      // Default successful token fetch
      when(mockTokenService.fetchToken(any, any)).thenAnswer((_) async => 'dummy_token');
      
      // Default successful room connection 
      when(mockRoom.connect(any, any, roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions')))
          .thenAnswer((_) async => Future.value()); 
    });

    test('successful connection flow emits correct states', () async {
      final List<ConnectionStatusUpdate> actualStates = [];
      connectionService.statusStream.listen(actualStates.add);

      final roomEventsController = StreamController<RoomEvent>.broadcast();
      when(mockRoom.events).thenAnswer((_) => roomEventsController.stream);
      
      // Override the default connect mock to trigger RoomConnectEvent
      when(mockRoom.connect(any, any, roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions')))
          .thenAnswer((_) async {
              // Schedule the event to be added to the stream after the current microtask queue is processed.
              // This ensures that the 'connecting' state is emitted before 'connected'.
              Future.microtask(() => roomEventsController.add(RoomConnectEvent(room: mockRoom)));
              return Future.value();
          });

      await connectionService.connect(roomName: 'test-room', participantName: 'test-user');
      
      // Wait for events to propagate
      await Future.delayed(const Duration(milliseconds: 100)); // Increased delay slightly

      // Verify the sequence of states
      expect(actualStates.map((s) => s.state), orderedEquals([
        ConnectionStateUpdate.initial, // From constructor
        ConnectionStateUpdate.permissionRequired, // From _checkPermissionsEarly -> granted
        ConnectionStateUpdate.initial, // From _checkPermissionsEarly -> 'Permissions Checked'
        ConnectionStateUpdate.permissionRequired, // From connect()->_requestPermissions (already granted)
        ConnectionStateUpdate.permissionRequired, // From connect()->_requestPermissions (granted status update)
        ConnectionStateUpdate.tokenFetching,      // "Fetching token..."
        ConnectionStateUpdate.tokenFetching,      // "Token fetched, ready to connect."
        ConnectionStateUpdate.connecting,
        ConnectionStateUpdate.connected,
      ]), reason: "Actual states: ${actualStates.map((s) => s.state).toList()}");

      verify(mockTokenService.fetchToken('test-room', 'test-user')).called(1);
      verify(mockRoom.connect('ws://dummy-url:7880', 'dummy_token', roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions'))).called(1);
      expect(connectionService.isConnecting, isFalse, reason: "isConnecting should be false after connection.");
      
      await roomEventsController.close();
    });

    test('token fetching failure emits error state', () async {
      when(mockTokenService.fetchToken(any, any)).thenThrow(const SocketException('Network failed'));

      connectionService.connect(roomName: 'test-room', participantName: 'test-user');

      await expectLater(
        connectionService.statusStream,
        emitsThrough(isA<ConnectionStatusUpdate>()
            .having((s) => s.state, 'state', ConnectionStateUpdate.error)
            .having((s) => s.errorType, 'errorType', ErrorType.network) 
            .having((s) => s.message, 'message', 'Network error. Please check your connection.')
            ),
      );
      expect(connectionService.isConnecting, isFalse);
    });

    test('room.connect() failure (LiveKitClientException) emits error state', () async {
      when(mockRoom.connect(any, any, roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions')))
          .thenThrow(LiveKitClientException('Simulated LiveKit connection error'));

      connectionService.connect(roomName: 'test-room', participantName: 'test-user');

      await expectLater(
        connectionService.statusStream,
        emitsThrough(isA<ConnectionStatusUpdate>()
            .having((s) => s.state, 'state', ConnectionStateUpdate.error)
            .having((s) => s.errorType, 'errorType', ErrorType.livekitClient)
            .having((s) => s.message, 'message', 'Failed to connect. Please try again.')
            ),
      );
      expect(connectionService.isConnecting, isFalse);
    });
    
    test('room.connect() failure (SocketException) emits network error state', () async {
      when(mockRoom.connect(any, any, roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions')))
          .thenThrow(const SocketException('Simulated network connection error'));

      connectionService.connect(roomName: 'test-room', participantName: 'test-user');

      await expectLater(
        connectionService.statusStream,
        emitsThrough(isA<ConnectionStatusUpdate>()
            .having((s) => s.state, 'state', ConnectionStateUpdate.error)
            .having((s) => s.errorType, 'errorType', ErrorType.network)
            .having((s) => s.message, 'message', 'Network error. Please check your connection.')
            ),
      );
      expect(connectionService.isConnecting, isFalse);
    });

    // For connection timeout, fake_async is ideal.
    // Add `dev_dependencies: fake_async: <version>` to pubspec.yaml
    // Then import 'package:fake_async/fake_async.dart';
    // And wrap the test body with `fakeAsync((async) { ... async.elapse(...); })`
    // For this controlled environment, I will assume fake_async is not available
    // and skip this test as direct timer manipulation is complex.
    test('connection timeout emits timeout error state', () {
       print("SKIPPING connection timeout test - requires fake_async package and setup for robust timer control.");
    }, skip: true); 
  });
  
  group('Permissions Handling', () {
    setUp(() {
      // Common stubs for successful connection post-permission
      when(mockTokenService.fetchToken(any, any)).thenAnswer((_) async => 'dummy_token');
      when(mockRoom.connect(any, any, roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions')))
          .thenAnswer((_) async {
            Future.microtask(() {
              final roomEventsController = StreamController<RoomEvent>.broadcast(sync: true); // sync for immediate emission in test
              when(mockRoom.events).thenAnswer((_) => roomEventsController.stream);
              roomEventsController.add(RoomConnectEvent(room: mockRoom));
              // Not closing controller here as it might be used by other event emissions in tests
            });
            return Future.value();
          });
    });

    test('connect requests and grants permission if initially denied by _checkPermissionsEarly', () async {
      // _checkPermissionsEarly runs in constructor. Default setUp already mocks denied for checkPermissionStatus.
      // Mock requestPermissions to grant it.
      await setMockRequestPermissionResult({Permission.microphone: PermissionStatus.granted});

      final List<ConnectionStatusUpdate> actualStates = [];
      connectionService.statusStream.listen(actualStates.add);
      
      connectionService.connect(roomName: 'test', participantName: 'test');
      await Future.delayed(const Duration(milliseconds: 100)); // Allow async operations

      expect(actualStates, contains(isA<ConnectionStatusUpdate>()
          .having((s) => s.message, 'message', 'Requesting microphone permission...')));
      expect(actualStates, contains(isA<ConnectionStatusUpdate>()
          .having((s) => s.message, 'message', 'Microphone permission granted.')));
      expect(connectionService.permissionsGranted, isTrue);
      expect(actualStates.any((s) => s.state == ConnectionStateUpdate.connected), isTrue, 
          reason: "Should proceed to connected state. Actual: ${actualStates.map((s)=>s.state).toList()}");
    });

    test('connect fails if permission request is denied', () async {
      // _checkPermissionsEarly runs in constructor. Default setUp already mocks denied for checkPermissionStatus.
      await setMockRequestPermissionResult({Permission.microphone: PermissionStatus.denied});

      final List<ConnectionStatusUpdate> actualStates = [];
      connectionService.statusStream.listen(actualStates.add);

      connectionService.connect(roomName: 'test', participantName: 'test');
      await Future.delayed(const Duration(milliseconds: 50));

      expect(actualStates, contains(isA<ConnectionStatusUpdate>()
          .having((s) => s.state, 'state', ConnectionStateUpdate.error)
          .having((s) => s.errorType, 'errorType', ErrorType.permissions)
          .having((s) => s.message, 'message', 'Microphone permission denied.')));
      expect(connectionService.permissionsGranted, isFalse);
      verifyNever(mockTokenService.fetchToken(any, any));
      verifyNever(mockRoom.connect(any, any, roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions')));
    });

    test('connect proceeds if permission was already granted (checked by _checkPermissionsEarly)', () async {
      // Re-initialize service for this test after setting up mocks for constructor-time calls
      await setMockPermissionStatus(PermissionStatus.granted); // For _checkPermissionsEarly
      connectionService.dispose(); 
      connectionService = ConnectionService(mockRoom, mockTokenService, initialServerUrl: 'ws://dummy-url:7880');
      
      // Ensure subsequent requests (if any, though should be skipped) also show granted
      await setMockRequestPermissionResult({Permission.microphone: PermissionStatus.granted});


      final List<ConnectionStatusUpdate> actualStates = [];
      final subscription = connectionService.statusStream.listen(actualStates.add);
      
      final roomEventsController = StreamController<RoomEvent>.broadcast(sync:true);
      when(mockRoom.events).thenAnswer((_) => roomEventsController.stream);
      when(mockRoom.connect(any, any, roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions')))
          .thenAnswer((_) async {
              Future.microtask(() => roomEventsController.add(RoomConnectEvent(room: mockRoom)));
              return Future.value();
          });

      await connectionService.connect(roomName: 'test', participantName: 'test');
      await Future.delayed(const Duration(milliseconds: 100));

      expect(actualStates.any((s) => s.message == 'Permissions checked.'), isTrue, 
        reason: "_checkPermissionsEarly should have set this. States: ${actualStates.map((s)=>s.message).toList()}");
      expect(actualStates.where((s) => s.message == 'Requesting microphone permission...'), isEmpty,
        reason: "Should not request permissions again if already granted by _checkPermissionsEarly.");
      
      expect(connectionService.permissionsGranted, isTrue);
      expect(actualStates.any((s) => s.state == ConnectionStateUpdate.connected), isTrue,
           reason: "Should proceed to connected. States: ${actualStates.map((s) => s.state).toList()}");
      
      await subscription.cancel();
      await roomEventsController.close();
    });
  });

  group('Disconnection', () {
    final roomEventsController = StreamController<RoomEvent>.broadcast(sync: true);
    setUp(() async {
      // Assume permissions are granted
      await setMockPermissionStatus(PermissionStatus.granted);
      await setMockRequestPermissionResult({Permission.microphone: PermissionStatus.granted});
      
      when(mockTokenService.fetchToken(any, any)).thenAnswer((_) async => 'dummy_token');
      when(mockRoom.events).thenAnswer((_) => roomEventsController.stream);
      when(mockRoom.connect(any, any, roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions')))
          .thenAnswer((_) async {
            when(mockRoom.connectionState).thenReturn(ConnectionState.connected); // Simulate connected state
            Future.microtask(() => roomEventsController.add(RoomConnectEvent(room: mockRoom)));
            return Future.value();
          });
      when(mockRoom.disconnect()).thenAnswer((_) async {
         when(mockRoom.connectionState).thenReturn(ConnectionState.disconnected);
         Future.microtask(() => roomEventsController.add(RoomDisconnectedEvent(room: mockRoom, reason: DisconnectReason.user)));
         return Future.value();
      });
      
      // Connect the service
      await connectionService.connect(roomName: 'test', participantName: 'test');
      await Future.delayed(const Duration(milliseconds: 50)); // ensure connection completes
    });

    tearDown(() async {
      if (!roomEventsController.isClosed) {
        await roomEventsController.close();
      }
    });

    test('disconnect successfully updates status and calls room.disconnect', () async {
      final List<ConnectionStatusUpdate> disconnectionStates = [];
      // Skip initial connection states for this specific test
      final sub = connectionService.statusStream.skipWhile((s) => s.state != ConnectionStateUpdate.connected).listen(disconnectionStates.add);
      
      await connectionService.disconnect();
      await Future.delayed(const Duration(milliseconds: 50)); // allow events to process

      verify(mockRoom.disconnect()).called(1);
      
      expect(disconnectionStates.map((s) => s.state), containsAllInOrder([
        ConnectionStateUpdate.connected, // Last state before disconnect call
        ConnectionStateUpdate.disconnected, // "Disconnecting..." message
        ConnectionStateUpdate.disconnected  // From RoomDisconnectedEvent
      ]), reason: "Actual states: ${disconnectionStates.map((s) => s.state).toList()}");
      
      expect(disconnectionStates.last.message, contains('Disconnected from room'));
      await sub.cancel();
    });
  });

  group('Connectivity Monitoring', () {
    late StreamController<ConnectivityResult> connectivityController;

    setUp(() {
      connectivityController = StreamController<ConnectivityResult>.broadcast();
      when(mockConnectivity.onConnectivityChanged).thenAnswer((_) => connectivityController.stream);
      
      // Re-initialize ConnectionService to inject the mockConnectivity properly for onConnectivityChanged
      connectionService.dispose(); // Dispose the one from global setUp
      connectionService = ConnectionService(mockRoom, mockTokenService, initialServerUrl: 'ws://dummy-url:7880');
      // This relies on the ConnectionService constructor calling _setupConnectivityMonitor which uses Connectivity() internally.
      // A more robust way would be to inject Connectivity, but this is harder with the current singleton-like usage in the service.
      // For this test, we'll assume that if we mock the global Connectivity stream, our service picks it up.
      // This is a limitation of testing singletons or direct instantiations.
      // The provided code for ConnectionService instantiates Connectivity() directly.
      // To properly test this, ConnectionService should accept Connectivity as a dependency.
      // For now, this test might not work as expected unless Connectivity() is a singleton that can be mocked globally.
      // print("WARNING: Connectivity tests might not be reliable due to direct instantiation of Connectivity() in service.");
    });

    tearDown(() async {
       await connectivityController.close();
    });

    test('losing connectivity emits network error state', () async {
      // This test is conceptually correct but might fail due to DI issue mentioned above.
      // To make it work, ConnectionService should allow injecting Connectivity mock.
      // For now, we will proceed as if the mock can be picked up.
      
      // Simulate connectivity change after a brief delay to ensure listener is set up
      Future.delayed(Duration.zero, () => connectivityController.add(ConnectivityResult.none));

      await expectLater(
        connectionService.statusStream,
        emitsThrough(isA<ConnectionStatusUpdate>()
            .having((s) => s.state, 'state', ConnectionStateUpdate.error)
            .having((s) => s.errorType, 'errorType', ErrorType.network)
            .having((s) => s.message, 'message', 'No internet connection. Please check your network.')),
      );
    }, skip: "Connectivity mocking needs DI in ConnectionService");

    test('restoring connectivity attempts reconnect if previously connected', () async {
      // 1. Setup for successful connection
      await setMockPermissionStatus(PermissionStatus.granted);
      await setMockRequestPermissionResult({Permission.microphone: PermissionStatus.granted});
      when(mockTokenService.fetchToken(any, any)).thenAnswer((_) async => 'dummy_token');
      final roomEventsCtrl = StreamController<RoomEvent>.broadcast(sync:true);
      when(mockRoom.events).thenAnswer((_) => roomEventsCtrl.stream);
      when(mockRoom.connect(any, any, roomOptions: anyNamed('roomOptions'), connectOptions: anyNamed('connectOptions')))
          .thenAnswer((_) async {
            when(mockRoom.isConnected).thenReturn(true); // After connect, it's connected
            Future.microtask(() => roomEventsCtrl.add(RoomConnectEvent(room: mockRoom)));
            return Future.value();
          });
      
      await connectionService.connect(roomName: 'test-room', participantName: 'test-user');
      await Future.delayed(const Duration(milliseconds: 50)); // Ensure connection
      
      // 2. Simulate losing connectivity
      Future.delayed(Duration.zero, () => connectivityController.add(ConnectivityResult.none));
      await expectLater(
        connectionService.statusStream,
        emitsThrough(isA<ConnectionStatusUpdate>()..having((s) => s.message, 'message', 'No internet connection. Please check your network.'))
      );
      when(mockRoom.isConnected).thenReturn(false); // Now it's not connected

      // 3. Simulate restoring connectivity
      clearInteractions(mockTokenService); // Clear previous calls for verification
      Future.delayed(Duration.zero, () => connectivityController.add(ConnectivityResult.wifi));
      
      // Check for "Internet connection restored."
      await expectLater(
         connectionService.statusStream,
         emitsThrough(isA<ConnectionStatusUpdate>()..having((s) => s.message, 'message', 'Internet connection restored.'))
      );
      // Then check for reconnect attempt (e.g., token fetching)
      await expectLater(
         connectionService.statusStream,
         emitsThrough(isA<ConnectionStatusUpdate>()..having((s) => s.state, 'state', ConnectionStateUpdate.reconnecting))
      );
      
      await Future.delayed(const Duration(milliseconds: 50)); // Allow reconnect attempt
      verify(mockTokenService.fetchToken('test-room', 'test-user')).called(1); // Reconnect should try to fetch token again

      await roomEventsCtrl.close();
    }, skip: "Connectivity mocking needs DI in ConnectionService");
  });
}

// Helper to mock permission status
Future<void> setMockPermissionStatus(PermissionStatus status) async {
  TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(
    const MethodChannel('flutter.base/permission_handler'),
    (MethodCall methodCall) async {
      if (methodCall.method == 'checkPermissionStatus') {
        return status.index;
      }
      if (methodCall.method == 'requestPermissions') {
        // Assume the first permission in the list is the one we care about for simplicity
        return { (methodCall.arguments as List<int>).first : status.index };
      }
      return null;
    },
  );
}

// Helper to mock permission request result
Future<void> setMockRequestPermissionResult(Map<Permission, PermissionStatus> results) async {
    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(
         const MethodChannel('flutter.base/permission_handler'),
        (MethodCall methodCall) async {
        if (methodCall.method == 'requestPermissions') {
            // The argument is List<int> representing permission group values.
            // We need to map these back to Permission enums if we want to be very specific,
            // but for these tests, we often mock a single permission result.
            // This simplified mock assumes the first requested permission gets the first status.
            List<int> requestedPermissionIndices = methodCall.arguments.cast<int>();
            Map<int, int> response = {};
            results.forEach((permission, status) {
                 // This is tricky because the actual int value of Permission enum is not directly exposed
                 // For robust mocking, one might need to know the specific int values.
                 // For this example, let's assume we are mostly mocking microphone (index 9) or camera (index 0)
                 // and only one is requested at a time in the SUT for these tests.
                 // A more robust solution would involve a lookup or assuming the test setup matches the SUT call.
                 if (requestedPermissionIndices.isNotEmpty) {
                    response[requestedPermissionIndices.first] = status.index;
                 }
            });
            return response;
        }
         if (methodCall.method == 'checkPermissionStatus') {
            // Return a default status for checks, can be overridden by specific test setups
            return PermissionStatus.denied.index; 
        }
        return null;
        },
    );
}

// Note: After writing this, I'd run `flutter pub run build_runner build --delete-conflicting-outputs`
// to generate `connection_service_test.mocks.dart`.
// The actual tests will be added in subsequent steps.
